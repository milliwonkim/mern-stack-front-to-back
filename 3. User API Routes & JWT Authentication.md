\* Chapter 9: Creating The User Model
=====================================

1\. update

- User.js

```js
//models/User.js

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

/**Create Schema */
const UserSchema = new Schema({
    name: {
        type: String,
        /**this is how we define the field */
        required: true
    },
    email: {
        type: String,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    avatar: {
        type: String,
        required: true
    },
    date: {
        type: Date,
        default: Date.now
    }
});

module.exports = User = mongoose.model('users', UserSchema);
```

\* Chapter 10: User Registration & Postman
==========================================

1\. update

- users.js

- server.js

- User.js

2.

![](images/10-user-registration-and-postman-1.png)

![](images/10-user-registration-and-postman-2.png)

![](images/10-user-registration-and-postman-3.png)

![](images/10-user-registration-and-postman-4.png)

![](images/10-user-registration-and-postman-5.png)

![](images/10-user-registration-and-postman-6.png)

![](images/10-user-registration-and-postman-7.png)

![](images/10-user-registration-and-postman-8.png)

![](images/10-user-registration-and-postman-9.png)

![](images/10-user-registration-and-postman-10.png)

```js
//models/User.js

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

/**Create Schema */
const UserSchema = new Schema({
    name: {
        type: String,
        /**this is how we define the field */
        required: true
    },
    email: {
        type: String,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    avatar: {
        type: String,
/** 'required: true' in here is necessary
 * because we are not actually getting that in as an input
 * it's getting stored programmatically through that file with the email
*/
        //required: true
    },
    date: {
        type: Date,
        default: Date.now
    }
});

module.exports = User = mongoose.model('users', UserSchema);

```

```js
//server.js

//entry-point file

const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');

const users = require('./routes/api/users');
const profile = require('./routes/api/profile');
const posts = require('./routes/api/posts');

//initialize
const app = express();

/** Body Parser middleware
 *  so we can access req.body
 */
app.use(bodyParser.urlencoded({extended: false}));
app.use(bodyParser.json());

/**DB config */
const db = require('./config/keys').mongoURI;

/**connect to MongoDB
 * using promise
*/
mongoose
.connect(db)
.then(() => console.log('MongoDB Connected'))
.catch(err => console.log(err));

//simple route to get something up and running
app.get('/', (req, res) => res.send('Hello'));

/** Use Routes */
app.use('/api/users', users);
app.use('/api/profile', profile);
app.use('/api/posts', posts);

/**when you deploy to Heroku, you wanna set it to process.env.PORT || 5000 */
const port = process.env.PORT || 5000;

/** using backtick to use dynamic variable */
app.listen(port, () => console.log(`Server running on port ${port}`))
```

```js
//routes/api/users.js

const express = require('express');
const router = express.Router();
const gravatar = require('gravatar');
const bcrypt = require('bcryptjs');

/** Load User Model */
const User = require('../../models/User')

/**you don't need to say '/api/users/test'
 * because we already did in server.js 'app.use('/api/users', users);'
*/

/**res.json() is similar to res.send()
 * res.json() will automatically serve a status of 200 which means everything is OK
*/

/** JSON Web Token for access a private route
 * you will have to send a token along with it by registering
 * and then logging in and it sends you a token
 * you then send that token with your request
 */

/** @route             GET api/users/test*/
/** @desc(description) Test users route */
/** @access            Public */
router.get('/test', (req, res) => res.json({msg: "Users Works"}));

/** @route             GET api/users/register*/
/** @desc(description) Register user */
/** @access            Public */
router.post('/register', (req, res) => {
    /**we don't want to register with an email that is already in the database
     * findOne() allows us to looking for a record that has an email the user is trying to register
    */
    User.findOne({ email: req.body.email })
        .then(user => {
            if(user) {
                return res.status(400).json({email: 'Email already exists'});
            } else {
                /** 'avatar' will be used in 'avatar' in newUser variable */
                const avatar = gravatar.url(req.body.email, {
                    s: '200', /** Size*/
                    r: 'pg', /** Rating */
                    d: 'mm' /** Default */
                });

                const newUser = new User({
                    name: req.body.name,
                    email: req.body.email,
                    //if key is same to value, then you can use just only 'avatar'
                    //avatar,
                    avatar: avatar,
                    password: req.body.password
                });
/** once we get that salt, we want to create our hash with our hash or passwor
 */
                bcrypt.genSalt(10, (err, salt) => {
/** if we get err, display err
 * but if not, we get hash which is what we wanna store in the database
 */
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if(err) throw err;
/**set the newUser.password to hash */
                        newUser.password = hash;
                        newUser
                            .save()
                            .then(user => res.json(user))
                            .catch(err => console.log(err));
                    })
                })
            }
        })
});

module.exports = router;
```

\* Chapter11: Email And Password Login
======================================

1\. update

- users.js

2.

![](images/11-email-and-password-login-1.png)

![](images/11-email-and-password-login-2.png)

![](images/11-email-and-password-login-3.png)

```js
//routes/api/users.js

const express = require('express');
const router = express.Router();
const gravatar = require('gravatar');
const bcrypt = require('bcryptjs');

/** Load User Model */
const User = require('../../models/User')

/**you don't need to say '/api/users/test'
 * because we already did in server.js 'app.use('/api/users', users);'
*/

/**res.json() is similar to res.send()
 * res.json() will automatically serve a status of 200 which means everything is OK
*/

/** JSON Web Token for access a private route
 * you will have to send a token along with it by registering
 * and then logging in and it sends you a token
 * you then send that token with your request
 */

/** @route             GET api/users/test*/
/** @desc(description) Test users route */
/** @access            Public */
router.get('/test', (req, res) => res.json({msg: "Users Works"}));

/** @route             GET api/users/register*/
/** @desc(description) Register user */
/** @access            Public */
router.post('/register', (req, res) => {
    /**we don't want to register with an email that is already in the database
     * findOne() allows us to looking for a record that has an email the user is trying to register
    */
    User.findOne({ email: req.body.email })
        .then(user => {
            if(user) {
                return res.status(400).json({email: 'Email already exists'});
            } else {
                /** 'avatar' will be used in 'avatar' in newUser variable */
                const avatar = gravatar.url(req.body.email, {
                    s: '200', /** Size*/
                    r: 'pg', /** Rating */
                    d: 'mm' /** Default */
                });

                const newUser = new User({
                    name: req.body.name,
                    email: req.body.email,
                    //if key is same to value, then you can use just only 'avatar'
                    //avatar,
                    avatar: avatar,
                    password: req.body.password
                });
/** once we get that salt, we want to create our hash with our hash or passwor
 */
                bcrypt.genSalt(10, (err, salt) => {
/** if we get err, display err
 * but if not, we get hash which is what we wanna store in the database
 */
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if(err) throw err;
/**set the newUser.password to hash */
                        newUser.password = hash;
                        newUser
                            .save()
                            .then(user => res.json(user))
                            .catch(err => console.log(err));
                    })
                })
            }
        })
});

/** @route             GET api/users/login*/
/** @desc(description) Login User / Returning JWT Token */
/** @access            Public */
router.post('/login', (req, res) => {
    /** using body-parser */
    const email = req.body.email;
    const password = req.body.password;

    /** Find user by email */
    User.findOne({ email: email })
        .then(user => {
            /** Check for user */
            if(!user) {
                return res.status(404).json({ email: 'User not found' });
            }

            /**Check Password */
            bcrypt.compare(password, user.password)
                .then(isMatch => {
                    if(isMatch){
                        res.json({msg: 'Success'});
                    } else{
            /** these names like password or something like that is very important
             * because we are actually gonna be using these messages on the front end when we get them
             */
                        return res.status(400).json({password: 'Password incorrect'});
                    }
                })
        });
});

module.exports = router;
```

\* Chapter 12: Creating The JWT
===============================

1\. update

- users.js

- keys.js

2.

![](images/12-creating-the-jwt-1.png)

```js
//routes/api/users.js

const express = require('express');
const router = express.Router();
const gravatar = require('gravatar');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const keys = require('../../config/keys')

/** Load User Model */
const User = require('../../models/User')

/**you don't need to say '/api/users/test'
 * because we already did in server.js 'app.use('/api/users', users);'
*/

/**res.json() is similar to res.send()
 * res.json() will automatically serve a status of 200 which means everything is OK
*/

/** JSON Web Token for access a private route
 * you will have to send a token along with it by registering
 * and then logging in and it sends you a token
 * you then send that token with your request
 */

/** @route             GET api/users/test*/
/** @desc(description) Test users route */
/** @access            Public */
router.get('/test', (req, res) => res.json({msg: "Users Works"}));

/** @route             GET api/users/register*/
/** @desc(description) Register user */
/** @access            Public */
router.post('/register', (req, res) => {
    /**we don't want to register with an email that is already in the database
     * findOne() allows us to looking for a record that has an email the user is trying to register
    */
    User.findOne({ email: req.body.email })
        .then(user => {
            if(user) {
                return res.status(400).json({email: 'Email already exists'});
            } else {
                /** 'avatar' will be used in 'avatar' in newUser variable */
                const avatar = gravatar.url(req.body.email, {
                    s: '200', /** Size*/
                    r: 'pg', /** Rating */
                    d: 'mm' /** Default */
                });

                const newUser = new User({
                    name: req.body.name,
                    email: req.body.email,
                    //if key is same to value, then you can use just only 'avatar'
                    //avatar,
                    avatar: avatar,
                    password: req.body.password
                });
/** once we get that salt, we want to create our hash with our hash or passwor
 */
                bcrypt.genSalt(10, (err, salt) => {
/** if we get err, display err
 * but if not, we get hash which is what we wanna store in the database
 */
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if(err) throw err;
/**set the newUser.password to hash */
                        newUser.password = hash;
                        newUser
                            .save()
                            .then(user => res.json(user))
                            .catch(err => console.log(err));
                    })
                })
            }
        })
});

/** @route             GET api/users/login*/
/** @desc(description) Login User / Returning JWT Token */
/** @access            Public */
router.post('/login', (req, res) => {
    /** using body-parser */
    const email = req.body.email;
    const password = req.body.password;

    /** Find user by email */
    User.findOne({ email: email })
        .then(user => {
            /** Check for user */
            if(!user) {
                return res.status(404).json({ email: 'User not found' });
            }

            /**Check Password */
            bcrypt.compare(password, user.password)
                .then(isMatch => {
                    if(isMatch){
                        /**User Matched */
                        /**Create JWT Payload */
                        const payload = {id: user.id, name: user.name, avatar: user.avatar}

                        /** Sign Token */
                        /**it's gonna take in a payload which is what we wanna include in the token
                         * what we wanna include is some user information
                         * because when that token gets sent to the server
                         * we wanna decode it and it needs to know what user it is
                         * also we need to send a secret key, we know we need to send a expiration if we want it to expire in a certain amount of time
                         */
                        jwt.sign(payload, keys.secretOrKey, { expiresIn: 3600 }, (err, token) => {
                            res.json({
                                success: true,
                                /**the way we format these token in the header is by putting the word "Bearer"
                                 * or we are gonna be using a Bearer token which is a certain type of protocol
                                 * so we are gonna tack that on to the token. So we don't have to do it when we actually make the request
                                 */
                                token: 'Bearer ' + token
                            })
                        });
                    } else{
            /** these names like password or something like that is very important
             * because we are actually gonna be using these messages on the front end when we get them
             */
                        return res.status(400).json({password: 'Password incorrect'});
                    }
                })
        });
});

module.exports = router;
```

```js
//config/keys.js

module.exports = {
    mongoURI: 'mongodb://brad:brad123@ds129260.mlab.com:29260/dev-connector',
    secretOrKey: 'secret'
};
```

\* Chapter 13: Passport JWT Authentication Strategy
===================================================

1\. update

- server.js

- passport.js

- users.js

2.

![](images/13-passport-jwt-authentication-strategy-1.png)

- that's perfect because we didn't send a token to access private route

this is private, it's unauthorized without the token

![](images/13-passport-jwt-authentication-strategy-2.png)

- this is the valid login. that's why i got this.

![](images/13-passport-jwt-authentication-strategy-3.png)

![](images/13-passport-jwt-authentication-strategy-4.png)

- we will go back to where we are trying to access a protected route

- Notice that we are logging the payload from the token which has the ID the name the avatar

and then it also adds on the expiration and this is the issued at time and this is the expiration

- So this is working perfectly

- you can see we are getting the payload from the token

![](images/13-passport-jwt-authentication-strategy-5.png)

- after doing passport.js, then it works well it says "success"

![](images/13-passport-jwt-authentication-strategy-6.png)

- the way we can access the user from that route instead of sending success if we wanna send the user

the user is now in req.user

![](images/13-passport-jwt-authentication-strategy-7.png)

- we logged in with this tab and we got the token for this user

![](images/13-passport-jwt-authentication-strategy-8.png)

- then we tried to access a protected row. we first did it without the token you it was unauthorized

then we added the correct token. and now it's responding with the user

- if this is out like "unauthorized", then re-send picture 7 "http://localhost:5000/api/users/login"

- now i'm not gonna keep this as our response because we don't wanna send like the password even though it's a hash

we don't wanna send this back 

![](images/13-passport-jwt-authentication-strategy-9.png)

```js
//server.js

//entry-point file

const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
/**passport is the main authentication module
 * google O Auth or JWT is the sub Module
 */
const passport = require('passport');

const users = require('./routes/api/users');
const profile = require('./routes/api/profile');
const posts = require('./routes/api/posts');

//initialize
const app = express();

/** Body Parser middleware
 *  so we can access req.body
 */
app.use(bodyParser.urlencoded({extended: false}));
app.use(bodyParser.json());

/**DB config */
const db = require('./config/keys').mongoURI;

/**connect to MongoDB
 * using promise
*/
mongoose
.connect(db)
.then(() => console.log('MongoDB Connected'))
.catch(err => console.log(err));

/**Passport middleware */
app.use(passport.initialize());

/**Passport Config */
/**In passport, we use what's called a strategy
 * for instance, when we did the local authentication and that other course we had a local strategy
 * When we did google O Auth, then we had google strategy
 * so now we are gonna have a JWT strategy
 * and that's what is going to go in this config file
 */
require('./config/passport')(passport);

/** Use Routes */
app.use('/api/users', users);
app.use('/api/profile', profile);
app.use('/api/posts', posts);

/**when you deploy to Heroku, you wanna set it to process.env.PORT || 5000 */
const port = process.env.PORT || 5000;

/** using backtick to use dynamic variable */
app.listen(port, () => console.log(`Server running on port ${port}`))


```

```js
//config/passport.js

/**This is where we need to basically create our strategy */

const JwtStrategy = require('passport-jwt').Strategy;
/**"ExtractJWT" will enable us to extract the payload which is the user data
 * and do what we want with it
 */
const ExtractJwt = require('passport-jwt').ExtractJwt;
/**we are gonna bring in mongoose
 * because we are gonna be searching for the user that come with the payload
 */
const mongoose = require('mongoose');
/**"users" comes from module.exports = User = mongoose.model('users', UserSchema); in User.js */
const User = mongoose.model('users');
const keys = require('../config/keys');

const opts = {};
/**we are gonna use this one right here "fromAuthHeaderAsBearerToken()"  */

/**we are gonna specify that we wanna use a bearer token
  * remember we added that bearer string before token
  * we need to add the secret key which we have in our keys file
  */
opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();
opts.secretOrKey = keys.secretOrKey;

module.exports = passport => {
    passport.use(
        new JwtStrategy(opts, (jwt_payload, done) => {
    /** we included in our payload in users.js
     * 
    */
    /**What we want to do is just get the usuer that's being sent in the token */
    /**"jwt_payload" is the object that has the user ID in it */
            User.findById(jwt_payload.id)
                .then(user => {
                    if(user){
                        /**the first parameter is an error which there isn't any. So we gonna say null
                         * second is gonna be the actual user
                          */
                        return done(null, user);
                    }
                    /** if the user isn't found, we are still gonna return done
                     * and we are still gonna return as the first parameter
                     * but false as the second because there is no user
                     */
                    return done(null, false);
                })
                .catch(err => console.log(err));
        })
    );
}
```

```js
//routes/api/users.js

const express = require('express');
const router = express.Router();
const gravatar = require('gravatar');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const keys = require('../../config/keys')
const passport = require('passport');

/** Load User Model */
const User = require('../../models/User')

/**you don't need to say '/api/users/test'
 * because we already did in server.js 'app.use('/api/users', users);'
*/

/**res.json() is similar to res.send()
 * res.json() will automatically serve a status of 200 which means everything is OK
*/

/** JSON Web Token for access a private route
 * you will have to send a token along with it by registering
 * and then logging in and it sends you a token
 * you then send that token with your request
 */

/** @route             GET api/users/test*/
/** @desc(description) Test users route */
/** @access            Public */
router.get('/test', (req, res) => res.json({msg: "Users Works"}));

/** @route             GET api/users/register*/
/** @desc(description) Register user */
/** @access            Public */
router.post('/register', (req, res) => {
    /**we don't want to register with an email that is already in the database
     * findOne() allows us to looking for a record that has an email the user is trying to register
    */
    User.findOne({ email: req.body.email })
        .then(user => {
            if(user) {
                return res.status(400).json({email: 'Email already exists'});
            } else {
                /** 'avatar' will be used in 'avatar' in newUser variable */
                const avatar = gravatar.url(req.body.email, {
                    s: '200', /** Size*/
                    r: 'pg', /** Rating */
                    d: 'mm' /** Default */
                });

                const newUser = new User({
                    name: req.body.name,
                    email: req.body.email,
                    //if key is same to value, then you can use just only 'avatar'
                    //avatar,
                    avatar: avatar,
                    password: req.body.password
                });
/** once we get that salt, we want to create our hash with our hash or passwor
 */
                bcrypt.genSalt(10, (err, salt) => {
/** if we get err, display err
 * but if not, we get hash which is what we wanna store in the database
 */
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if(err) throw err;
/**set the newUser.password to hash */
                        newUser.password = hash;
                        newUser
                            .save()
                            .then(user => res.json(user))
                            .catch(err => console.log(err));
                    })
                })
            }
        })
});

/** @route             GET api/users/login*/
/** @desc(description) Login User / Returning JWT Token */
/** @access            Public */
router.post('/login', (req, res) => {
    /** using body-parser */
    const email = req.body.email;
    const password = req.body.password;

    /** Find user by email */
    User.findOne({ email: email })
        .then(user => {
            /** Check for user */
            if(!user) {
                return res.status(404).json({ email: 'User not found' });
            }

            /**Check Password */
            bcrypt.compare(password, user.password)
                .then(isMatch => {
                    if(isMatch){
                        /**User Matched */
                        /**Create JWT Payload */
                        const payload = {id: user.id, name: user.name, avatar: user.avatar}

                        /** Sign Token */
                        /**it's gonna take in a payload which is what we wanna include in the token
                         * what we wanna include is some user information
                         * because when that token gets sent to the server
                         * we wanna decode it and it needs to know what user it is
                         * also we need to send a secret key, we know we need to send a expiration if we want it to expire in a certain amount of time
                         */
                        jwt.sign(payload, keys.secretOrKey, { expiresIn: 3600 }, (err, token) => {
                            res.json({
                                success: true,
                                /**the way we format these token in the header is by putting the word "Bearer"
                                 * or we are gonna be using a Bearer token which is a certain type of protocol
                                 * so we are gonna tack that on to the token. So we don't have to do it when we actually make the request
                                 */
                                token: 'Bearer ' + token
                            })
                        });
                    } else{
            /** these names like password or something like that is very important
             * because we are actually gonna be using these messages on the front end when we get them
             */
                        return res.status(400).json({password: 'Password incorrect'});
                    }
                })
        });
});

/** @route             GET api/users/current*/
/** @desc(description) Return current user */
/** @access            Private */

/**"jwt" is the strategy we are using
 * "session: false" is because we are not using session
*/
/**e
 */
router.get(
    '/current', 
    passport.authenticate('jwt', { session: false }), 
    (req, res) => {
        res.json({
            id: req.user.id,
            name: req.user.name,
            email: req.user.email
        });
});

module.exports = router;
```

\* Chapter 14: Validation Handlers - 1
======================================

1\. update

- login.js(validation folder)

- register.js(validation folder)

- is-empty.js(validation folder)

- users.js(route/api folder)

2.

![](images/14-validation-handlers-1-1.png)

```js
//validation/login.js

//empty
```

```js
//validation/register.js

/**it has to be a string that you are validating
 * empty has to be a string
 */
const Validator = require('validator');
const isEmpty = require('./is-empty');

/**we will be able to access this function from outside */
module.exports = function validateRegisterInput(data){
    /** we start off with an empty errors
     * and if everything passes it will still be empty at the end
     * and it will be valid
     * if not then "errors.name" will get filled and then it won't be empty
     * and it won't be valid
     * and
     * if(!isValid){ return res.status(400).json(errors); }
     * this will return all the errors
    */
    let errors = {};

    if(!Validator.isLength(data.name, { min: 2, max: 30 })){
        errors.name = 'Name must be between 2 and 30 characters';
    }

    return{
        errors,
        isValid: isEmpty(errors)
    }
}

```

```js
//validation/is-empty.js

/**This is my is-empty function that will check for a undefined, null, empty object, empty string
 * as opposed to the validator, is-empty which is only gonna check for empty string
*/
const isEmpty = value =>
        value === undefined ||
        value === null ||
        (typeof value === 'object' && Object.keys(value).length === 0) ||
        (typeof value === 'string' && value.trim().length === 0);

/**above is equal to this below
 *
 * function isEmpty(value){
    return(
        value === undefined ||
        value === null ||
        (typeof value === 'object' && Object.keys(value).length === 0) ||
        (typeof value === 'string' && value.trim().length === 0)
    );
} */

module.exports = isEmpty;
```

```js
//routes/api/users.js

const express = require('express');
const router = express.Router();
const gravatar = require('gravatar');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const keys = require('../../config/keys')
const passport = require('passport');

/**Load Input Validation */
const validateRegisterInput = require('../../validation/register');

/** Load User Model */
const User = require('../../models/User')

/**you don't need to say '/api/users/test'
 * because we already did in server.js 'app.use('/api/users', users);'
*/

/**res.json() is similar to res.send()
 * res.json() will automatically serve a status of 200 which means everything is OK
*/

/** JSON Web Token for access a private route
 * you will have to send a token along with it by registering
 * and then logging in and it sends you a token
 * you then send that token with your request
 */

/** @route             GET api/users/test*/
/** @desc(description) Test users route */
/** @access            Public */
router.get('/test', (req, res) => res.json({msg: "Users Works"}));

/** @route             GET api/users/register*/
/** @desc(description) Register user */
/** @access            Public */
router.post('/register', (req, res) => {

    /**inside the register route, before we do anything and we are gonna be doing this for just about every route 
     * that takes in data we wanna pull out the errors in isValid from below
     * return{
         errors,
         isValid: isEmpty(errors)
       }
     * and we just brought in and we can use destructuring for that
     */

     /** req.body includes everything that's sent to this route 
      * which in this case will be the name, email, password
      */
    const { errors, isValid } = validateRegisterInput(req.body)

    /**Check Validation */
    if(!isValid){
        /**we wanna send along the whole the entire error's object */
        return res.status(400).json(errors);
    }

    /**we don't want to register with an email that is already in the database
     * findOne() allows us to looking for a record that has an email the user is trying to register
    */
    User.findOne({ email: req.body.email })
        .then(user => {
            if(user) {
                errors.email = 'Email already exists';
                return res.status(400).json(errors);
            } else {
                /** 'avatar' will be used in 'avatar' in newUser variable */
                const avatar = gravatar.url(req.body.email, {
                    s: '200', /** Size*/
                    r: 'pg', /** Rating */
                    d: 'mm' /** Default */
                });

                const newUser = new User({
                    name: req.body.name,
                    email: req.body.email,
                    //if key is same to value, then you can use just only 'avatar'
                    //avatar,
                    avatar: avatar,
                    password: req.body.password
                });
/** once we get that salt, we want to create our hash with our hash or passwor
 */
                bcrypt.genSalt(10, (err, salt) => {
/** if we get err, display err
 * but if not, we get hash which is what we wanna store in the database
 */
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if(err) throw err;
/**set the newUser.password to hash */
                        newUser.password = hash;
                        newUser
                            .save()
                            .then(user => res.json(user))
                            .catch(err => console.log(err));
                    })
                })
            }
        })
});

/** @route             GET api/users/login*/
/** @desc(description) Login User / Returning JWT Token */
/** @access            Public */
router.post('/login', (req, res) => {
    /** using body-parser */
    const email = req.body.email;
    const password = req.body.password;

    /** Find user by email */
    User.findOne({ email: email })
        .then(user => {
            /** Check for user */
            if(!user) {
                return res.status(404).json({ email: 'User not found' });
            }

            /**Check Password */
            bcrypt.compare(password, user.password)
                .then(isMatch => {
                    if(isMatch){
                        /**User Matched */
                        /**Create JWT Payload */
                        const payload = {id: user.id, name: user.name, avatar: user.avatar}

                        /** Sign Token */
                        /**it's gonna take in a payload which is what we wanna include in the token
                         * what we wanna include is some user information
                         * because when that token gets sent to the server
                         * we wanna decode it and it needs to know what user it is
                         * also we need to send a secret key, we know we need to send a expiration if we want it to expire in a certain amount of time
                         */
                        jwt.sign(payload, keys.secretOrKey, { expiresIn: 3600 }, (err, token) => {
                            res.json({
                                success: true,
                                /**the way we format these token in the header is by putting the word "Bearer"
                                 * or we are gonna be using a Bearer token which is a certain type of protocol
                                 * so we are gonna tack that on to the token. So we don't have to do it when we actually make the request
                                 */
                                token: 'Bearer ' + token
                            })
                        });
                    } else{
            /** these names like password or something like that is very important
             * because we are actually gonna be using these messages on the front end when we get them
             */
                        return res.status(400).json({password: 'Password incorrect'});
                    }
                })
        });
});

/** @route             GET api/users/current*/
/** @desc(description) Return current user */
/** @access            Private */

/**"jwt" is the strategy we are using
 * "session: false" is because we are not using session
*/
/**e
 */
router.get(
    '/current', 
    passport.authenticate('jwt', { session: false }), 
    (req, res) => {
        res.json({
            id: req.user.id,
            name: req.user.name,
            email: req.user.email
        });
});

module.exports = router;
```

\* Chapter 15:

- chapter 15

1\. update

- register(validation folder)

- login.js(validation folder)

- users.js(routes/api folder)

2.

![](images/15-validation-handlers-2-1.png)

![](images/15-validation-handlers-2-2.png)

![](images/15-validation-handlers-2-3.png)

![](images/15-validation-handlers-2-4.png)

![](images/15-validation-handlers-2-5.png)

![](images/15-validation-handlers-2-6.png)

![](images/15-validation-handlers-2-7.png)

![](images/15-validation-handlers-2-8.png)

![](images/15-validation-handlers-2-9.png)

![](images/15-validation-handlers-2-10.png)

![](images/15-validation-handlers-2-11.png)

![](images/15-validation-handlers-2-12.png)

![](images/15-validation-handlers-2-13.png)

```js
//validation/register.js

/**it has to be a string that you are validating
 * empty has to be a string
 */
const Validator = require('validator');
const isEmpty = require('./is-empty');

/**=========================================================================== */

/**we will be able to access this function from outside */
module.exports = function validateRegisterInput(data){
    /** we start off with an empty errors
     * and if everything passes it will still be empty at the end
     * and it will be valid
     * if not then "errors.name" will get filled and then it won't be empty
     * and it won't be valid
     * and
     * if(!isValid){ return res.status(400).json(errors); }
     * this will return all the errors
    */
    let errors = {};

    /**what we wanna do is if we are testing for something to be empty
     * we first need it to be an empty string
     */

    data.name = !isEmpty(data.name) ? data.name : '';

    /**we are gonna have a field called password2
     * which is not used on the server
     * but we still wanna validate that
     * make sure that it's actually being sent
     * because even though this stuff we are putting on the server
     * these responses these tasks are gonna be run from the client
     * the client is gonna go through the server and get sent back to the client
     */

    data.email = !isEmpty(data.email) ? data.email : '';
    data.password = !isEmpty(data.password) ? data.password : '';
    data.password2 = !isEmpty(data.password2) ? data.password2 : '';

/**----------------------------------------------------------------------- */

    if(!Validator.isLength(data.name, { min: 2, max: 30 })){
        errors.name = 'Name must be between 2 and 30 characters';
    }

    /**the problem is if your request is sent and they don't send the name,
     * it's not gonna be a empty string
     * that's what it needs to be for this isEmpty to work 
     * because that's part of the validator
     * so this needs 'data.name = !isEmpty(data.name) ? data.name : '';'
     */

    if(Validator.isEmpty(data.name)){
        errors.name = 'Name field is required';
    }
/**----------------------------------------------------------------------- */
    if(Validator.isEmpty(data.email)){
        errors.email = 'Email field is required';
    }

    if(!Validator.isEmail(data.email)){
        errors.email = 'Email field is invalid';
    }
/**----------------------------------------------------------------------- */
    if(Validator.isEmpty(data.password)){
        errors.password = 'Password field is required';
    }

    if(!Validator.isLength(data.password, { min: 6, max: 30 })){
        errors.password = 'Password must be at least 6 characters';
    }
/**----------------------------------------------------------------------- */
    if(Validator.isEmpty(data.password2)){
        errors.password2 = 'Confirm Password field is required';
    }

    if(!Validator.equals(data.password, data.password2)){
        errors.password2 = 'Passwords must match';
    }

    return{
        errors,
        isValid: isEmpty(errors)
    }
}
```

```js
//validation/login.js

/**it has to be a string that you are validating
 * empty has to be a string
 */
const Validator = require('validator');
const isEmpty = require('./is-empty');

/**=========================================================================== */

/**we will be able to access this function from outside */
module.exports = function validateLoginInput(data){
    /** we start off with an empty errors
     * and if everything passes it will still be empty at the end
     * and it will be valid
     * if not then "errors.name" will get filled and then it won't be empty
     * and it won't be valid
     * and
     * if(!isValid){ return res.status(400).json(errors); }
     * this will return all the errors
    */
    let errors = {};

    data.email = !isEmpty(data.email) ? data.email : '';
    data.password = !isEmpty(data.password) ? data.password : '';
/**----------------------------------------------------------------------- */

    /**the problem is if your request is sent and they don't send the name,
     * it's not gonna be a empty string
     * that's what it needs to be for this isEmpty to work 
     * because that's part of the validator
     * so this needs 'data.name = !isEmpty(data.name) ? data.name : '';'
     */

/**----------------------------------------------------------------------- */

    if(!Validator.isEmail(data.email)){
        errors.email = 'Email field is invalid';
    }

    if(Validator.isEmpty(data.email)){
        errors.email = 'Email field is required';
    }
    
/**----------------------------------------------------------------------- */
    if(Validator.isEmpty(data.password)){
        errors.password = 'Password field is required';
    }

/**----------------------------------------------------------------------- */
    return{
        errors,
        isValid: isEmpty(errors)
    }
}
```

```js
//routes/api/users.js

const express = require('express');
const router = express.Router();
const gravatar = require('gravatar');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const keys = require('../../config/keys')
const passport = require('passport');

/**Load Input Validation */
const validateRegisterInput = require('../../validation/register');
const validateLoginInput = require('../../validation/login');

/** Load User Model */
const User = require('../../models/User')

/**=========================================================================== */

/**you don't need to say '/api/users/test'
 * because we already did in server.js 'app.use('/api/users', users);'
*/

/**res.json() is similar to res.send()
 * res.json() will automatically serve a status of 200 which means everything is OK
*/

/** JSON Web Token for access a private route
 * you will have to send a token along with it by registering
 * and then logging in and it sends you a token
 * you then send that token with your request
 */

/** @route             GET api/users/test*/
/** @desc(description) Test users route */
/** @access            Public */
router.get('/test', (req, res) => res.json({msg: "Users Works"}));

/** @route             GET api/users/register*/
/** @desc(description) Register user */
/** @access            Public */
router.post('/register', (req, res) => {

    /**inside the register route, before we do anything and we are gonna be doing this for just about every route 
     * that takes in data we wanna pull out the errors in isValid from below
     * return{
         errors,
         isValid: isEmpty(errors)
       }
     * and we just brought in and we can use destructuring for that
     */

     /** req.body includes everything that's sent to this route 
      * which in this case will be the name, email, password
      */

/**----------------------------------------------------------------------- */

    const { errors, isValid } = validateRegisterInput(req.body)

    /**Check Validation */
    if(!isValid){
        /**we wanna send along the whole the entire error's object */
        return res.status(400).json(errors);
    }

    /**we don't want to register with an email that is already in the database
     * findOne() allows us to looking for a record that has an email the user is trying to register
    */
    User.findOne({ email: req.body.email })
        .then(user => {
            if(user) {
                errors.email = 'Email already exists';
                return res.status(400).json(errors);
            } else {
                /** 'avatar' will be used in 'avatar' in newUser variable */
                const avatar = gravatar.url(req.body.email, {
                    s: '200', /** Size*/
                    r: 'pg', /** Rating */
                    d: 'mm' /** Default */
                });

                const newUser = new User({
                    name: req.body.name,
                    email: req.body.email,
                    //if key is same to value, then you can use just only 'avatar'
                    //avatar,
                    avatar: avatar,
                    password: req.body.password
                });
/** once we get that salt, we want to create our hash with our hash or passwor
 */
                bcrypt.genSalt(10, (err, salt) => {
/** if we get err, display err
 * but if not, we get hash which is what we wanna store in the database
 */
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if(err) throw err;
/**set the newUser.password to hash */
                        newUser.password = hash;
                        newUser
                            .save()
                            .then(user => res.json(user))
                            .catch(err => console.log(err));
                    })
                })
            }
        })
});

/**----------------------------------------------------------------------- */

/** @route             GET api/users/login*/
/** @desc(description) Login User / Returning JWT Token */
/** @access            Public */
router.post('/login', (req, res) => {

    const { errors, isValid } = validateLoginInput(req.body)

    /**Check Validation */
    if(!isValid){
        /**we wanna send along the whole the entire error's object */
        return res.status(400).json(errors);
    }

    /** using body-parser */
    const email = req.body.email;
    const password = req.body.password;

    /** Find user by email */
    User.findOne({ email: email })
        .then(user => {
            /** Check for user */
            if(!user) {
                errors.email = 'User not found';
                return res.status(404).json(errors);
            }

            /**Check Password */
            bcrypt.compare(password, user.password)
                .then(isMatch => {
                    if(isMatch){
                        /**User Matched */
                        /**Create JWT Payload */
                        const payload = {id: user.id, name: user.name, avatar: user.avatar}

                        /** Sign Token */
                        /**it's gonna take in a payload which is what we wanna include in the token
                         * what we wanna include is some user information
                         * because when that token gets sent to the server
                         * we wanna decode it and it needs to know what user it is
                         * also we need to send a secret key, we know we need to send a expiration if we want it to expire in a certain amount of time
                         */
                        jwt.sign(payload, keys.secretOrKey, { expiresIn: 3600 }, (err, token) => {
                            res.json({
                                success: true,
                                /**the way we format these token in the header is by putting the word "Bearer"
                                 * or we are gonna be using a Bearer token which is a certain type of protocol
                                 * so we are gonna tack that on to the token. So we don't have to do it when we actually make the request
                                 */
                                token: 'Bearer ' + token
                            })
                        });
                    } else{
                        errors.password = 'Password incorrect';
            /** these names like password or something like that is very important
             * because we are actually gonna be using these messages on the front end when we get them
             */
                        return res.status(400).json(errors);
                    }
                })
        });
});

/**----------------------------------------------------------------------- */

/** @route             GET api/users/current*/
/** @desc(description) Return current user */
/** @access            Private */

/**"jwt" is the strategy we are using
 * "session: false" is because we are not using session
*/
/**e
 */
router.get(
    '/current', 
    passport.authenticate('jwt', { session: false }), 
    (req, res) => {
        res.json({
            id: req.user.id,
            name: req.user.name,
            email: req.user.email
        });
});

module.exports = router;
```